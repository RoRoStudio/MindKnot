-e 

// ==== ./index.ts ====

import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);
-e 

// ==== ./App.tsx ====

// App.tsx (update the useEffect for database initialization)
import React, { useEffect, useState } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { Text, View } from 'react-native';
import AppNavigator from './src/navigation/AppNavigator';
import { initDatabase } from './src/services/sqliteService';

export default function App() {
  const [dbInitialized, setDbInitialized] = useState(false);
  const [dbError, setDbError] = useState<string | null>(null);

  useEffect(() => {
    const initialize = async () => {
      try {
        console.log("Starting database initialization...");
        await initDatabase();
        console.log("Database initialization complete");
        setDbInitialized(true);
      } catch (error) {
        console.error("Failed to initialize database:", error);
        setDbError(error instanceof Error ? error.message : String(error));
      }
    };

    initialize();
  }, []);

  if (dbError) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <Text style={{ color: 'red' }}>Database Error: {dbError}</Text>
      </View>
    );
  }

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        <NavigationContainer>
          <AppNavigator />
        </NavigationContainer>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}-e 

// ==== ./src/theme/light.ts ====

import { baseColors, lightColors } from '../styles/colors';

export const lightTheme = {
    ...lightColors,
    ...baseColors,
    primary: baseColors.nodeBlue,
};
-e 

// ==== ./src/theme/dark.ts ====

import { baseColors, darkColors } from '../styles/colors';

export const darkTheme = {
    ...darkColors,
    ...baseColors,
    primary: baseColors.nodeBlue,
};
-e 

// ==== ./src/state/useMindMapStore.ts ====

import { create } from 'zustand';
import { StateCreator } from 'zustand';
import { NodeModel } from '../types/NodeTypes';
import { getAllNodes, insertNode, updateNode, deleteAllNodes } from '../services/sqliteService';
import { nanoid } from 'nanoid/non-secure';

type MindMapState = {
    nodes: NodeModel[];
    loadNodes: () => Promise<void>;
    addNode: (partial: Partial<NodeModel>) => Promise<void>;
    updateNodePosition: (id: string, x: number, y: number) => Promise<void>;
    clearAllNodes: () => Promise<void>;
};

// Define a more specific type for the store creator
type MindMapStoreCreator = StateCreator<MindMapState>;

export const useMindMapStore = create<MindMapState>((set, get) => ({
    nodes: [],

    loadNodes: async () => {
        try {
            console.log("Loading nodes from database...");
            const loaded: NodeModel[] = await getAllNodes();
            set({ nodes: loaded });
            console.log(`Loaded ${loaded.length} nodes`);
        } catch (error) {
            console.error('Error loading nodes:', error);
            set({ nodes: [] });
        }
    },

    addNode: async (partial) => {
        try {
            // Generate ID first to ensure it's valid
            const nodeId = nanoid();
            console.log("Generated node ID:", nodeId);

            // Log the partial data we received
            console.log("Adding new node with properties:", JSON.stringify(partial));

            const now = Date.now();

            // Create node with defaults for any missing properties
            const node: NodeModel = {
                id: nodeId,
                title: partial.title ?? 'Untitled',
                body: partial.body ?? '',
                icon: partial.icon ?? '',
                color: partial.color ?? '#2D9CDB',
                x: partial.x ?? 100, // Use nullish coalescing to handle 0 correctly
                y: partial.y ?? 100, // Use nullish coalescing to handle 0 correctly
                template: (partial.template as any) ?? 'quicknote',
                status: partial.status ?? '',
                createdAt: now,
                updatedAt: now,
            };

            console.log("Created full node object:", JSON.stringify(node));

            // Update state first for immediate feedback
            set((state) => {
                const newNodes = [...state.nodes, node];
                console.log(`Updated state, now have ${newNodes.length} nodes`);
                return { nodes: newNodes };
            });

            // Then save to database
            const success = await insertNode(node);
            if (!success) {
                console.warn("Database insertion failed, but state was updated");
            }
        } catch (error) {
            console.error('Error adding node:', error);
            // Include stack trace for debugging
            if (error instanceof Error) {
                console.error('Stack trace:', error.stack);
            }
        }
    },

    updateNodePosition: async (id, x, y) => {
        try {
            const now = Date.now();

            set((state) => {
                const updatedNodes = state.nodes.map((node) =>
                    node.id === id ? { ...node, x, y, updatedAt: now } : node
                );
                return { nodes: updatedNodes };
            });

            const updatedNode = get().nodes.find((node) => node.id === id);
            if (updatedNode) {
                await updateNode({ ...updatedNode, x, y, updatedAt: now });
            }
        } catch (error) {
            console.error('Error updating node position:', error);
        }
    },

    clearAllNodes: async () => {
        try {
            await deleteAllNodes();
            set({ nodes: [] });
        } catch (error) {
            console.error('Error clearing nodes:', error);
        }
    },
}));-e 

// ==== ./src/services/sqliteService.ts ====

import * as SQLite from 'expo-sqlite';
import { NodeModel } from '../types/NodeTypes';

let db: SQLite.SQLiteDatabase | null = null;

export async function initDatabase() {
  try {
    console.log("Initializing database...");
    db = await SQLite.openDatabaseAsync('mindknot.db');

    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS nodes (
        id TEXT PRIMARY KEY NOT NULL,
        title TEXT,
        body TEXT,
        icon TEXT,
        color TEXT,
        x REAL,
        y REAL,
        template TEXT,
        status TEXT,
        createdAt INTEGER,
        updatedAt INTEGER
      );
      
      CREATE TABLE IF NOT EXISTS links (
        id TEXT PRIMARY KEY NOT NULL,
        sourceId TEXT,
        targetId TEXT,
        type TEXT,
        createdAt INTEGER
      );
    `);
    console.log("Database initialized successfully");
  } catch (error) {
    console.error("Error initializing database:", error);
  }
}

export async function getAllNodes(): Promise<NodeModel[]> {
  try {
    if (!db) {
      console.warn("Database not initialized when trying to get all nodes");
      return [];
    }
    const result = await db.getAllAsync<NodeModel>('SELECT * FROM nodes;');
    return result;
  } catch (error) {
    console.error("Error getting all nodes:", error);
    return [];
  }
}

export async function insertNode(node: NodeModel): Promise<boolean> {
  try {
    if (!db) {
      console.error("Database not initialized when trying to insert node");
      return false;
    }
    console.log("Inserting node into database:", node.id);

    await db.runAsync(
      `INSERT OR REPLACE INTO nodes 
        (id, title, body, icon, color, x, y, template, status, createdAt, updatedAt) 
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);`,
      [
        node.id,
        node.title,
        node.body || '',
        node.icon || '',
        node.color,
        node.x,
        node.y,
        node.template,
        node.status || '',
        node.createdAt,
        node.updatedAt,
      ]
    );
    console.log("Node inserted successfully:", node.id);
    return true;
  } catch (error) {
    console.error("Error inserting node:", error);
    return false;
  }
}

export async function updateNode(node: NodeModel): Promise<boolean> {
  try {
    if (!db) {
      console.error("Database not initialized when trying to update node");
      return false;
    }

    await db.runAsync(
      `UPDATE nodes SET x = ?, y = ?, updatedAt = ? WHERE id = ?;`,
      [node.x, node.y, node.updatedAt, node.id]
    );
    return true;
  } catch (error) {
    console.error("Error updating node:", error);
    return false;
  }
}

export async function deleteAllNodes(): Promise<boolean> {
  try {
    if (!db) {
      console.error("Database not initialized when trying to delete all nodes");
      return false;
    }

    await db.runAsync('DELETE FROM nodes;');
    return true;
  } catch (error) {
    console.error("Error deleting all nodes:", error);
    return false;
  }
}-e 

// ==== ./src/styles/spacing.ts ====

export const spacing = {
    xs: 4,
    s: 8,
    m: 16,
    l: 24,
    xl: 32,
};
-e 

// ==== ./src/styles/colors.ts ====

export const baseColors = {
    white: '#ffffff',
    black: '#000000',
    nodeBlue: '#2D9CDB',
    urgentRed: '#EB5757',
    textSecondary: '#666666',
};

export const lightColors = {
    background: '#ffffff',
    textPrimary: '#1A1A1A',
    surface: '#F2F2F2',
    border: '#E0E0E0',
};

export const darkColors = {
    background: '#121212',
    textPrimary: '#ffffff',
    surface: '#1E1E1E',
    border: '#333333',
};
-e 

// ==== ./src/styles/typography.ts ====

export const typography = {
    fontSize: {
      xs: 10,
      s: 12,
      m: 14,
      l: 18,
      xl: 24,
      xxl: 32,
    },
    fontWeight: {
      regular: '400',
      medium: '500',
      bold: '700',
    },
    lineHeight: {
      tight: 16,
      normal: 20,
      relaxed: 28,
    },
  };
  -e 

// ==== ./src/styles/index.ts ====

export * from './colors';
export * from './spacing';
export * from './typography';
-e 

// ==== ./src/types/NodeTypes.ts ====

export type NodeTemplate = 'quicknote' | 'checklist' | 'bullet' | 'decision';

export interface NodeModel {
    id: string;
    title: string;
    body?: string;
    icon?: string;
    color: string;
    x: number;
    y: number;
    template: NodeTemplate;
    status?: string;
    createdAt: number;
    updatedAt: number;
}

export interface LinkModel {
    id: string;
    sourceId: string;
    targetId: string;
    type: 'default' | 'cause' | 'reference' | 'related';
    createdAt: number;
}
-e 

// ==== ./src/types/svg.d.ts ====

declare module '*.svg' {
    import * as React from 'react';
    import { SvgProps } from 'react-native-svg';
    const content: React.FC<SvgProps>;
    export default content;
}
-e 

// ==== ./src/components/nodes/NodeCard.tsx ====

// src/components/nodes/NodeCard.tsx
import React, { useEffect } from 'react';
import { Text, StyleSheet, Platform, View, FlexAlignType } from 'react-native';
import { PanGestureHandler } from 'react-native-gesture-handler';
import Animated, {
    useAnimatedGestureHandler,
    useAnimatedStyle,
    useSharedValue,
    runOnJS,
} from 'react-native-reanimated';
import Matter from 'matter-js';
import { NodeModel } from '../../types/NodeTypes';

type Props = {
    body: Matter.Body;
    node: NodeModel;
    size: [number, number];
    color: string;
};

// Define context type for gesture handler
type GestureContext = {
    startX: number;
    startY: number;
};

const NodeCard: React.FC<Props> = ({ body, node, size, color }) => {
    // Use shared values to track position instead of directly using body
    const positionX = useSharedValue(body.position.x - size[0] / 2);
    const positionY = useSharedValue(body.position.y - size[1] / 2);

    // Update shared values when body position changes
    useEffect(() => {
        positionX.value = body.position.x - size[0] / 2;
        positionY.value = body.position.y - size[1] / 2;
    }, [body.position.x, body.position.y, size]);

    // Create the animated style using shared values - with proper TypeScript types
    const animatedStyle = useAnimatedStyle(() => {
        // Create base style with proper type annotations
        const baseStyle = {
            position: 'absolute' as const,
            left: positionX.value,
            top: positionY.value,
            width: size[0],
            height: size[1],
            backgroundColor: color,
            borderRadius: 12,
            justifyContent: 'center' as const,
            alignItems: 'center' as const,
        };

        // For Android, just add elevation
        if (Platform.OS === 'android') {
            return {
                ...baseStyle,
                elevation: 4,
            };
        }

        // For iOS, add shadow properties
        return {
            ...baseStyle,
            shadowColor: '#000',
            shadowOffset: { width: 0, height: 2 },
            shadowOpacity: 0.2,
            shadowRadius: 4,
        };
    });

    // Safe function to update physics body (runs on JS thread)
    const updatePhysicsBody = (x: number, y: number) => {
        Matter.Body.setPosition(body, {
            x: x + size[0] / 2,
            y: y + size[1] / 2
        });
    };

    const setBodyStatic = (isStatic: boolean) => {
        Matter.Body.setStatic(body, isStatic);
        if (!isStatic) {
            Matter.Body.setVelocity(body, { x: 0, y: 0 });
        }
    };

    // Define the drag gesture handler with worklet and runOnJS
    const gestureHandler = useAnimatedGestureHandler<any, GestureContext>({
        onStart: (_, ctx) => {
            ctx.startX = positionX.value;
            ctx.startY = positionY.value;
            // Make body static during drag
            runOnJS(setBodyStatic)(true);
        },
        onActive: (event, ctx) => {
            // Update shared values for UI
            const newX = ctx.startX + event.translationX;
            const newY = ctx.startY + event.translationY;
            positionX.value = newX;
            positionY.value = newY;

            // Update physics body on JS thread
            runOnJS(updatePhysicsBody)(newX, newY);
        },
        onEnd: () => {
            // Make body dynamic again after drag
            runOnJS(setBodyStatic)(false);
        },
    });

    return (
        <PanGestureHandler onGestureEvent={gestureHandler}>
            <Animated.View style={animatedStyle}>
                <Text style={styles.label} numberOfLines={1}>
                    {node.title}
                </Text>
            </Animated.View>
        </PanGestureHandler>
    );
};

const styles = StyleSheet.create({
    label: {
        color: '#1A1A1A',
        fontWeight: '500',
        textAlign: 'center',
        paddingHorizontal: 4,
    },
});

export default NodeCard;-e 

// ==== ./src/components/nodes/CreateNode.tsx ====

import React, { useState } from 'react';
import { View, StyleSheet, TouchableOpacity, Text } from 'react-native';
import { GestureDetector, Gesture } from 'react-native-gesture-handler';
import Animated, { runOnJS } from 'react-native-reanimated';
import { useMindMapStore } from '../../state/useMindMapStore';

export default function CreateNode() {
    const addNode = useMindMapStore((s) => s.addNode);
    const nodes = useMindMapStore((s) => s.nodes);

    const [menuPosition, setMenuPosition] = useState<{ x: number; y: number } | null>(null);

    const handleTap = (x: number, y: number) => {
        console.log('Tapped at:', x, y);
        setMenuPosition({ x, y });
    };

    const handleCreate = (template: string) => {
        if (!menuPosition) return;

        const color = '#' + Math.floor(Math.random() * 16777215).toString(16);
        addNode({
            x: menuPosition.x,
            y: menuPosition.y,
            color,
            title: `New ${template}`,
            template: template as any,
        });
        setMenuPosition(null);
    };

    const tap = Gesture.Tap().onEnd((e) => {
        runOnJS(handleTap)(e.absoluteX, e.absoluteY);
    });

    return (
        <GestureDetector gesture={tap}>
            <View style={StyleSheet.absoluteFill}>
                {menuPosition && (
                    <View style={[styles.menu, { left: menuPosition.x, top: menuPosition.y }]}>
                        <TouchableOpacity onPress={() => handleCreate('quicknote')}>
                            <Text style={styles.item}>Quick Note</Text>
                        </TouchableOpacity>
                        <TouchableOpacity onPress={() => handleCreate('checklist')}>
                            <Text style={styles.item}>Checklist</Text>
                        </TouchableOpacity>
                        <TouchableOpacity onPress={() => handleCreate('decision')}>
                            <Text style={styles.item}>Decision</Text>
                        </TouchableOpacity>
                        <TouchableOpacity onPress={() => handleCreate('bullet')}>
                            <Text style={styles.item}>Bullet</Text>
                        </TouchableOpacity>
                        <TouchableOpacity onPress={() => setMenuPosition(null)}>
                            <Text style={[styles.item, styles.cancel]}>Cancel</Text>
                        </TouchableOpacity>
                    </View>
                )}
            </View>
        </GestureDetector>
    );
}

const styles = StyleSheet.create({
    menu: {
        position: 'absolute',
        backgroundColor: '#fff',
        borderRadius: 8,
        elevation: 4,
        padding: 8,
        zIndex: 99,
    },
    item: {
        paddingVertical: 6,
        paddingHorizontal: 12,
        fontSize: 14,
        color: '#1A1A1A',
    },
    cancel: {
        color: '#EB5757',
        fontWeight: 'bold',
        marginTop: 6,
    },
});
-e 

// ==== ./src/components/canvas/PhysicsEngine.tsx ====

import Matter from 'matter-js';

// Define interfaces for better type safety
interface PhysicsEntities {
    physics: {
        engine: Matter.Engine;
        world: Matter.World;
    };
    [key: string]: any; // Add index signature for other entities
}

interface TimeInput {
    time: {
        delta: number;
        elapsed: number;
    };
    [key: string]: any; // For other possible inputs
}

// Create a clean engine instance
const engine = Matter.Engine.create({
    enableSleeping: false,
});
const world = engine.world;

// Disable gravity for this type of app
world.gravity.y = 0;
world.gravity.x = 0;

// Keep track of bodies that exist in the world for proper cleanup
const existingBodies = new Set<number>();

const physics = (entities: PhysicsEntities, { time }: TimeInput) => {
    // Safety check
    if (!entities || !entities.physics) {
        return entities;
    }

    // Update physics simulation with appropriate timing
    // Clamp the delta to avoid large time steps
    const delta = Math.min(time.delta, 16.667);
    Matter.Engine.update(engine, delta);

    // Process each entity
    Object.keys(entities).forEach((key) => {
        if (key === 'physics') return;

        const entity = entities[key];
        if (entity && entity.body && entity.node) {
            // Apply repulsion forces between nodes
            Object.keys(entities).forEach((otherKey) => {
                if (otherKey === 'physics' || otherKey === key) return;

                const otherEntity = entities[otherKey];
                if (!otherEntity || !otherEntity.body) return;

                // Skip if either body is static (being dragged)
                if (entity.body.isStatic || otherEntity.body.isStatic) return;

                const dx = entity.body.position.x - otherEntity.body.position.x;
                const dy = entity.body.position.y - otherEntity.body.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const minDistance = 60; // Minimum distance between nodes

                if (distance < minDistance && distance > 0) {
                    const angle = Math.atan2(dy, dx);
                    const force = 0.0001; // Even smaller force for smoother effect
                    const fx = Math.cos(angle) * force;
                    const fy = Math.sin(angle) * force;

                    Matter.Body.applyForce(entity.body, entity.body.position, { x: fx, y: fy });
                    Matter.Body.applyForce(otherEntity.body, otherEntity.body.position, { x: -fx, y: -fy });
                }
            });
        }
    });

    return entities;
};

// Expose function to clean up bodies that are no longer needed
const cleanupPhysics = (currentEntityKeys: string[]) => {
    const bodiesInWorld = Matter.Composite.allBodies(world);

    // Remove bodies that no longer have a corresponding entity
    bodiesInWorld.forEach(body => {
        // Skip the default world bounds
        if (body.label === "World Bounds") return;

        // If this body isn't in our current entities, remove it
        if (!currentEntityKeys.includes(body.label)) {
            Matter.World.remove(world, body);
            existingBodies.delete(body.id);
        }
    });
};

export { engine, world, physics, cleanupPhysics, existingBodies };-e 

// ==== ./src/components/canvas/Canvas.tsx ====

import React, { useEffect, useState, useRef, useCallback } from 'react';
import { StyleSheet, View, Dimensions } from 'react-native';
import { GameEngine } from 'react-native-game-engine';
import Matter from 'matter-js';
import { useMindMapStore } from '../../state/useMindMapStore';
import NodeCard from '../nodes/NodeCard';
import { engine, world, physics, cleanupPhysics, existingBodies } from './PhysicsEngine';

const NODE_SIZE = 50;
const { width, height } = Dimensions.get('window');

// Add interfaces for entity objects
interface GameEntity {
    body: Matter.Body;
    node: any;
    size: [number, number];
    color: string;
    renderer: React.FC<any>;
}

interface Entities {
    physics: {
        engine: Matter.Engine;
        world: Matter.World;
    };
    [key: string]: GameEntity | { engine: Matter.Engine; world: Matter.World };
}

export default function Canvas() {
    // Use individual selectors for better performance and proper context
    const nodes = useMindMapStore(state => state.nodes);
    const addNode = useMindMapStore(state => state.addNode);

    const [gameEngineKey, setGameEngineKey] = useState(0);
    const gameEngineRef = useRef(null);

    // Prepare entities based on nodes - make it memoized
    const prepareEntities = useCallback((): Entities => {
        console.log("Preparing entities for", nodes.length, "nodes");

        // Base entity with physics engine
        const entities: Entities = {
            physics: { engine, world }
        };

        // Track current entity IDs for cleanup
        const currentEntityKeys: string[] = ['physics'];

        // Create entities for each node
        nodes.forEach((node) => {
            // Use node ID as the entity key and Matter body label
            const entityKey = node.id;
            currentEntityKeys.push(entityKey);

            // Check if this body already exists in the world
            const existingBody = Matter.Composite.allBodies(world).find(
                body => body.label === entityKey
            );

            let body;

            if (existingBody) {
                // Use existing body, just update position if needed
                body = existingBody;

                // Prevent updating position if being dragged
                if (!body.isStatic) {
                    Matter.Body.setPosition(body, { x: node.x, y: node.y });
                }
            } else {
                // Create a new body
                body = Matter.Bodies.circle(node.x, node.y, NODE_SIZE / 2, {
                    label: entityKey,
                    restitution: 0.2,
                    frictionAir: 0.2,
                    friction: 0.1,
                });

                // Add to world
                Matter.World.add(world, body);
                console.log("Added new body to world:", entityKey);
            }

            // Create entity for this node
            entities[entityKey] = {
                body,
                node,
                size: [NODE_SIZE, NODE_SIZE],
                color: node.color,
                renderer: NodeCard
            } as GameEntity;
        });

        // Clean up any bodies that don't have entities anymore
        cleanupPhysics(currentEntityKeys);

        return entities;
    }, [nodes]);

    // Reset the game engine when nodes change
    useEffect(() => {
        try {
            // Refresh the game engine to avoid stale references
            setGameEngineKey(prev => prev + 1);
        } catch (err) {
            console.error("Error updating game engine:", err);
        }
    }, [nodes.length]); // Only recreate when nodes array length changes

    // Cleanup on unmount
    useEffect(() => {
        return () => {
            try {
                // Clear all physics bodies
                Matter.World.clear(world, false);
                Matter.Engine.clear(engine);
            } catch (err) {
                console.error("Error cleaning up physics:", err);
            }
        };
    }, []);

    return (
        <View style={styles.canvasWrapper}>
            <GameEngine
                key={gameEngineKey}
                ref={gameEngineRef}
                style={styles.gameEngine}
                systems={[physics]}
                entities={prepareEntities()}
                running={true}
            />
        </View>

    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#ffffff',
    },
    canvasWrapper: {
        flex: 1,
        width: '100%',
        height: '100%',
    },
    gameEngine: {
        flex: 1,
        backgroundColor: 'transparent',
    },
});-e 

// ==== ./src/components/canvas/PanZoomLayer.tsx ====

import React, { ReactNode } from 'react';
import { GestureDetector, Gesture } from 'react-native-gesture-handler';
import Animated, {
    useSharedValue,
    useAnimatedStyle,
} from 'react-native-reanimated';

interface Props {
    children: ReactNode;
}

export default function PanZoomLayer({ children }: Props) {
    const scale = useSharedValue(1);
    const translateX = useSharedValue(0);
    const translateY = useSharedValue(0);

    const pinch = Gesture.Pinch().onUpdate((e) => {
        scale.value = e.scale;
    });

    const pan = Gesture.Pan().onUpdate((e) => {
        translateX.value = e.translationX;
        translateY.value = e.translationY;
    });

    const gesture = Gesture.Simultaneous(pinch, pan);

    const animatedStyle = useAnimatedStyle(() => ({
        transform: [
            { translateX: translateX.value },
            { translateY: translateY.value },
            { scale: scale.value },
        ],
    }));

    return (
        <GestureDetector gesture={gesture}>
            <Animated.View style={[animatedStyle, { flex: 1 }]}>
                {children}
            </Animated.View>
        </GestureDetector>
    );
}-e 

// ==== ./src/components/common/Icon.tsx ====

import { SvgProps } from 'react-native-svg';

import Plus from '../../assets/icons/lucide/plus.svg';
import ArrowLeft from '../../assets/icons/lucide/arrow-left.svg';
import Check from '../../assets/icons/lucide/check.svg';
import Lightbulb from '../../assets/icons/lucide/lightbulb.svg';
import Map from '../../assets/icons/lucide/map.svg';
import Settings from '../../assets/icons/lucide/settings.svg';

const iconMap = {
    plus: Plus,
    'arrow-left': ArrowLeft,
    check: Check,
    lightbulb: Lightbulb,
    map: Map,
    settings: Settings,
};

export type IconName = keyof typeof iconMap;

type Props = SvgProps & {
    name: IconName;
};

export function Icon({ name, ...props }: Props) {
    const Component = iconMap[name];
    return <Component {...props} />;
}
-e 

// ==== ./src/navigation/BottomTabs.tsx ====

import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import CanvasScreen from '../screens/CanvasScreen';
import SettingsScreen from '../screens/SettingsScreen';
import { Icon } from '../components/common/Icon';
import { lightTheme } from '../theme/light';

const Tab = createBottomTabNavigator();

export default function BottomTabs() {
    return (
        <Tab.Navigator
            screenOptions={({ route }: { route: RouteProp<Record<string, object | undefined>, string> }) => {
                return {
                    headerStyle: { backgroundColor: lightTheme.background },
                    headerTitleStyle: { color: lightTheme.textPrimary },
                    tabBarStyle: { backgroundColor: lightTheme.background },
                    tabBarActiveTintColor: lightTheme.primary,
                    tabBarInactiveTintColor: lightTheme.textSecondary,
                    tabBarIcon: ({ color, size }: { color: string; size: number }) => {
                        const name = route.name === 'Canvas' ? 'map' : 'settings';
                        return <Icon name={name} width={size} height={size} stroke={color} />;
                    },
                } as BottomTabNavigationOptions;
            }}
        >
            <Tab.Screen name="Canvas" component={CanvasScreen} />
            <Tab.Screen name="Settings" component={SettingsScreen} />
        </Tab.Navigator>
    );
}
-e 

// ==== ./src/navigation/Routes.ts ====

export enum Routes {
    Canvas = 'Canvas',
    Map = 'Map',
    Settings = 'Settings',
}
-e 

// ==== ./src/navigation/AppNavigator.tsx ====

import React from 'react';
import BottomTabs from './BottomTabs';

export default function AppNavigator() {
    return <BottomTabs />;
}
-e 

// ==== ./src/screens/SettingsScreen.tsx ====

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { lightTheme } from '../theme/light';

export default function SettingsScreen() {
    return (
        <View style={styles.container}>
            <Text style={styles.text}>This is the Settings screen</Text>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: lightTheme.background,
        alignItems: 'center',
        justifyContent: 'center',
    },
    text: {
        color: lightTheme.textPrimary,
        fontSize: 18,
    },
});
-e 

// ==== ./src/screens/MapScreen.tsx ====

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { lightTheme } from '../theme/light';

export default function MapScreen() {
    return (
        <View style={styles.container}>
            <Text style={styles.text}>This is the Map screen</Text>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: lightTheme.background,
        alignItems: 'center',
        justifyContent: 'center',
    },
    text: {
        color: lightTheme.textPrimary,
        fontSize: 18,
    },
});
-e 

// ==== ./src/screens/CanvasScreen.tsx ====

import React, { useEffect } from 'react';
import { View, StyleSheet, Pressable, Text } from 'react-native';
import Canvas from '../components/canvas/Canvas';
import { useMindMapStore } from '../state/useMindMapStore';
import PanZoomLayer from '../components/canvas/PanZoomLayer';
import CreateNode from '../components/nodes/CreateNode';

export default function CanvasScreen() {
    const loadNodes = useMindMapStore((s) => s.loadNodes);
    const clearNodes = useMindMapStore((s) => s.clearAllNodes);

    useEffect(() => {
        loadNodes();
    }, []);

    return (
        <View style={styles.container}>
            <PanZoomLayer>
                <Canvas />
                <CreateNode />
            </PanZoomLayer>
            <Pressable style={styles.fab} onPress={clearNodes}>
                <Text style={styles.fabText}>ðŸ—‘</Text>
            </Pressable>
        </View>
    );

}

const styles = StyleSheet.create({
    container: {
        flex: 1,
    },
    fab: {
        position: 'absolute',
        right: 20,
        bottom: 20,
        backgroundColor: '#EB5757',
        width: 56,
        height: 56,
        borderRadius: 28,
        alignItems: 'center',
        justifyContent: 'center',
        elevation: 4,
    },
    fabText: {
        fontSize: 24,
        color: '#fff',
    },
});
