-e 

// ==== ./index.ts ====

import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);
-e 

// ==== ./App.tsx ====

// App.tsx (update the useEffect for database initialization)
import React, { useEffect, useState } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { Text, View } from 'react-native';
import AppNavigator from './src/navigation/AppNavigator';
import { initDatabase, resetDatabase } from './src/services/sqliteService';
import { ActionSheetProvider } from '@expo/react-native-action-sheet';


export default function App() {
  const [dbInitialized, setDbInitialized] = useState(false);
  const [dbError, setDbError] = useState<string | null>(null);

  useEffect(() => {
    const initialize = async () => {
      try {
        console.log('Starting database reset...');
        await resetDatabase(); // ‚Üê üö® TEMPORARY! COMMENT OUT WHEN WIPING SCHEMA IS NOT INTENTED
        console.log('Reset complete. Initializing database...');
        await initDatabase();
        console.log('Database initialization complete');
        setDbInitialized(true);
      } catch (error) {
        console.error("Failed to initialize database:", error);
        setDbError(error instanceof Error ? error.message : String(error));
      }
    };

    initialize();
  }, []);

  if (dbError) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <Text style={{ color: 'red' }}>Database Error: {dbError}</Text>
      </View>
    );
  }

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        <ActionSheetProvider>
          <NavigationContainer>
            <AppNavigator />
          </NavigationContainer>
        </ActionSheetProvider>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}-e 

// ==== ./src/theme/light.ts ====

import { baseColors, lightColors } from '../styles/colors';

export const lightTheme = {
    ...lightColors,
    ...baseColors,
    primary: baseColors.nodeBlue,
};
-e 

// ==== ./src/theme/dark.ts ====

import { baseColors, darkColors } from '../styles/colors';

export const darkTheme = {
    ...darkColors,
    ...baseColors,
    primary: baseColors.nodeBlue,
};
-e 

// ==== ./src/services/sqliteService.ts ====

// src/services/sqliteService.ts (update)
import * as SQLite from 'expo-sqlite';
import { NodeModel, LinkModel } from '../types/NodeTypes';

let db: SQLite.SQLiteDatabase | null = null;

export async function initDatabase() {
  try {
    console.log("Initializing database...");
    db = await SQLite.openDatabaseAsync('mindknot.db');

    await db.execAsync(`
      CREATE TABLE IF NOT EXISTS nodes (
        id TEXT PRIMARY KEY NOT NULL,
        title TEXT,
        body TEXT,
        icon TEXT,
        color TEXT,
        x REAL,
        y REAL,
        template TEXT,
        status TEXT,
        createdAt INTEGER,
        updatedAt INTEGER
      );
      
      CREATE TABLE IF NOT EXISTS links (
        id TEXT PRIMARY KEY NOT NULL,
        sourceId TEXT,
        targetId TEXT,
        label TEXT,
        color TEXT,
        style TEXT,
        type TEXT,
        createdAt INTEGER,
        updatedAt INTEGER,
        FOREIGN KEY (sourceId) REFERENCES nodes(id) ON DELETE CASCADE,
        FOREIGN KEY (targetId) REFERENCES nodes(id) ON DELETE CASCADE
      );
    `);
    console.log("Database initialized successfully");
  } catch (error) {
    console.error("Error initializing database:", error);
  }
}

export async function getAllNodes(): Promise<NodeModel[]> {
  try {
    if (!db) {
      console.warn("Database not initialized when trying to get all nodes");
      return [];
    }
    const result = await db.getAllAsync<NodeModel>('SELECT * FROM nodes;');
    return result;
  } catch (error) {
    console.error("Error getting all nodes:", error);
    return [];
  }
}

export async function getAllLinks(): Promise<LinkModel[]> {
  try {
    if (!db) {
      console.warn("Database not initialized when trying to get all links");
      return [];
    }
    const result = await db.getAllAsync<LinkModel>('SELECT * FROM links;');
    return result;
  } catch (error) {
    console.error("Error getting all links:", error);
    return [];
  }
}

export async function insertNode(node: NodeModel): Promise<boolean> {
  try {
    if (!db) {
      console.error("Database not initialized when trying to insert node");
      return false;
    }
    console.log("Inserting node into database:", node.id);

    await db.runAsync(
      `INSERT OR REPLACE INTO nodes 
        (id, title, body, icon, color, x, y, template, status, createdAt, updatedAt) 
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);`,
      [
        node.id,
        node.title,
        node.body || '',
        node.icon || '',
        node.color,
        node.x,
        node.y,
        node.template,
        node.status || '',
        node.createdAt,
        node.updatedAt,
      ]
    );
    console.log("Node inserted successfully:", node.id);
    return true;
  } catch (error) {
    console.error("Error inserting node:", error);
    return false;
  }
}

export async function insertLink(link: LinkModel): Promise<boolean> {
  try {
    if (!db) {
      console.error("Database not initialized when trying to insert link");
      return false;
    }
    console.log("Inserting link into database:", link.id);

    await db.runAsync(
      `INSERT OR REPLACE INTO links 
        (id, sourceId, targetId, label, color, style, type, createdAt, updatedAt) 
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?);`,
      [
        link.id,
        link.sourceId,
        link.targetId,
        link.label || '',
        link.color || '',
        link.style || 'solid',
        link.type,
        link.createdAt,
        link.updatedAt || link.createdAt,
      ]
    );
    console.log("Link inserted successfully:", link.id);
    return true;
  } catch (error) {
    console.error("Error inserting link:", error);
    return false;
  }
}

export async function updateNode(node: NodeModel): Promise<boolean> {
  try {
    if (!db) {
      console.error("Database not initialized when trying to update node");
      return false;
    }

    await db.runAsync(
      `UPDATE nodes SET x = ?, y = ?, updatedAt = ? WHERE id = ?;`,
      [node.x, node.y, node.updatedAt, node.id]
    );
    return true;
  } catch (error) {
    console.error("Error updating node:", error);
    return false;
  }
}

export async function deleteLink(linkId: string): Promise<boolean> {
  try {
    if (!db) {
      console.error("Database not initialized when trying to delete link");
      return false;
    }

    await db.runAsync('DELETE FROM links WHERE id = ?;', [linkId]);
    console.log("Link deleted successfully:", linkId);
    return true;
  } catch (error) {
    console.error("Error deleting link:", error);
    return false;
  }
}

export async function getLinksForNode(nodeId: string): Promise<LinkModel[]> {
  try {
    if (!db) {
      console.warn("Database not initialized when trying to get links for node");
      return [];
    }
    const result = await db.getAllAsync<LinkModel>(
      'SELECT * FROM links WHERE sourceId = ? OR targetId = ?;',
      [nodeId, nodeId]
    );
    return result;
  } catch (error) {
    console.error("Error getting links for node:", error);
    return [];
  }
}

export async function deleteAllNodes(): Promise<boolean> {
  try {
    if (!db) {
      console.error("Database not initialized when trying to delete all nodes");
      return false;
    }

    await db.runAsync('DELETE FROM links;');
    await db.runAsync('DELETE FROM nodes;');
    return true;
  } catch (error) {
    console.error("Error deleting all nodes:", error);
    return false;
  }
}

// DEV-ONLY: Reset the database by dropping all tables
export async function resetDatabase(): Promise<void> {
  const db = await SQLite.openDatabaseAsync('mindknot.db');
  await db.execAsync('DROP TABLE IF EXISTS links;');
  await db.execAsync('DROP TABLE IF EXISTS nodes;');
  console.log('[DEV] Dropped all tables');
}
-e 

// ==== ./src/styles/spacing.ts ====

export const spacing = {
    xs: 4,
    s: 8,
    m: 16,
    l: 24,
    xl: 32,
};
-e 

// ==== ./src/styles/colors.ts ====

export const baseColors = {
    white: '#ffffff',
    black: '#000000',
    nodeBlue: '#2D9CDB',
    urgentRed: '#EB5757',
    textSecondary: '#666666',
};

export const lightColors = {
    background: '#ffffff',
    textPrimary: '#1A1A1A',
    surface: '#F2F2F2',
    border: '#E0E0E0',
};

export const darkColors = {
    background: '#121212',
    textPrimary: '#ffffff',
    surface: '#1E1E1E',
    border: '#333333',
};
-e 

// ==== ./src/styles/typography.ts ====

export const typography = {
    fontSize: {
      xs: 10,
      s: 12,
      m: 14,
      l: 18,
      xl: 24,
      xxl: 32,
    },
    fontWeight: {
      regular: '400',
      medium: '500',
      bold: '700',
    },
    lineHeight: {
      tight: 16,
      normal: 20,
      relaxed: 28,
    },
  };
  -e 

// ==== ./src/styles/index.ts ====

export * from './colors';
export * from './spacing';
export * from './typography';
-e 

// ==== ./src/types/svg.d.ts ====

declare module '*.svg' {
    import * as React from 'react';
    import { SvgProps } from 'react-native-svg';
    const content: React.FC<SvgProps>;
    export default content;
}
-e 

// ==== ./src/components/common/Icon.tsx ====

import { SvgProps } from 'react-native-svg';

import Plus from '../../assets/icons/lucide/plus.svg';
import ArrowLeft from '../../assets/icons/lucide/arrow-left.svg';
import Check from '../../assets/icons/lucide/check.svg';
import Lightbulb from '../../assets/icons/lucide/lightbulb.svg';
import Map from '../../assets/icons/lucide/map.svg';
import Settings from '../../assets/icons/lucide/settings.svg';
import FileText from '../../assets/icons/lucide/file-text.svg';
import List from '../../assets/icons/lucide/list.svg';
import GitBranch from '../../assets/icons/lucide/git-branch.svg';
import Link from '../../assets/icons/lucide/link.svg';
import ArrowRight from '../../assets/icons/lucide/arrow-right.svg';
import Minus from '../../assets/icons/lucide/minus.svg';
import Sparkles from '../../assets/icons/lucide/sparkles.svg';

const iconMap = {
    plus: Plus,
    'arrow-left': ArrowLeft,
    'arrow-right': ArrowRight,
    check: Check,
    lightbulb: Lightbulb,
    map: Map,
    settings: Settings,
    'file-text': FileText,
    list: List,
    'git-branch': GitBranch,
    link: Link,
    minus: Minus,
    sparkles: Sparkles,
};

export type IconName = keyof typeof iconMap;

type Props = SvgProps & {
    name: IconName;
};

export function Icon({ name, ...props }: Props) {
    const Component = iconMap[name];

    if (!Component) {
        console.warn(`Icon '${name}' not found, using default.`);
        return <FileText {...props} />;
    }

    return <Component {...props} />;
}-e 

// ==== ./src/navigation/BottomTabs.tsx ====

import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import CanvasScreen from '../screens/CanvasScreen';
import SettingsScreen from '../screens/SettingsScreen';
import { Icon } from '../components/common/Icon';
import { lightTheme } from '../theme/light';

const Tab = createBottomTabNavigator();

export default function BottomTabs() {
    return (
        <Tab.Navigator
            screenOptions={({ route }: { route: RouteProp<Record<string, object | undefined>, string> }) => {
                return {
                    headerStyle: { backgroundColor: lightTheme.background },
                    headerTitleStyle: { color: lightTheme.textPrimary },
                    tabBarStyle: { backgroundColor: lightTheme.background },
                    tabBarActiveTintColor: lightTheme.primary,
                    tabBarInactiveTintColor: lightTheme.textSecondary,
                    tabBarIcon: ({ color, size }: { color: string; size: number }) => {
                        const name = route.name === 'Canvas' ? 'map' : 'settings';
                        return <Icon name={name} width={size} height={size} stroke={color} />;
                    },
                } as BottomTabNavigationOptions;
            }}
        >
            <Tab.Screen name="Canvas" component={CanvasScreen} />
            <Tab.Screen name="Settings" component={SettingsScreen} />
        </Tab.Navigator>
    );
}
-e 

// ==== ./src/navigation/Routes.ts ====

export enum Routes {
    Canvas = 'Canvas',
    Map = 'Map',
    Settings = 'Settings',
}
-e 

// ==== ./src/navigation/AppNavigator.tsx ====

import React from 'react';
import BottomTabs from './BottomTabs';

export default function AppNavigator() {
    return <BottomTabs />;
}
