-e 

// ==== ./App.tsx ====

import React, { useEffect } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import AppNavigator from './src/navigation/AppNavigator';
import { initDatabase } from './src/services/sqliteService';

export default function App() {
  useEffect(() => {
    initDatabase();
  }, []);

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        <NavigationContainer>
          <AppNavigator />
        </NavigationContainer>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}
-e 

// ==== ./index.ts ====

import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);
-e 

// ==== ./src/components/canvas/Canvas.tsx ====

// src/components/canvas/Canvas.tsx

import React, { useEffect } from 'react';
import { Dimensions, StyleSheet } from 'react-native';
import { GameEngine } from 'react-native-game-engine';
import Matter from 'matter-js';
import { useMindMapStore } from '../../state/useMindMapStore';
import NodeCard from '../nodes/NodeCard';
import { engine, world, physics } from './PhysicsEngine';

const NODE_SIZE = 50;
const { width, height } = Dimensions.get('window');

export default function Canvas() {
    const { nodes } = useMindMapStore();

    const entities: { [key: string]: any } = {
        physics: { engine, world },
    };

    nodes.forEach((node) => {
        const body = Matter.Bodies.circle(node.x, node.y, NODE_SIZE / 2, {
            label: node.id,
            restitution: 0.9,
            frictionAir: 0.15,
        });

        Matter.World.add(world, body);

        entities[node.id] = {
            body,
            node,
            size: [NODE_SIZE, NODE_SIZE],
            color: node.color,
            renderer: NodeCard,
        };
    });

    useEffect(() => {
        return () => {
            Matter.World.clear(world, false);
            Matter.Engine.clear(engine);
        };
    }, []);

    return (
        <GameEngine
            style={styles.container}
            systems={[physics]}
            entities={entities}
            running
        />
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#ffffff',
    },
});
-e 

// ==== ./src/components/canvas/PhysicsEngine.tsx ====

// src/components/canvas/PhysicsEngine.tsx

import Matter from 'matter-js';
import { useMindMapStore } from '../../state/useMindMapStore';

const engine = Matter.Engine.create({ enableSleeping: false });
const world = engine.world;

const physics = (entities: any, { time }: any) => {
    Matter.Engine.update(engine, time.delta);

    const { updateNodePosition } = useMindMapStore.getState();

    Object.keys(entities).forEach((key) => {
        if (key === 'physics') return;

        const { body, node } = entities[key];
        if (body && node) {
            // Update node position in the store
            updateNodePosition(node.id, body.position.x, body.position.y);

            // Soft balloon-style pushing
            Object.keys(entities).forEach((otherKey) => {
                if (otherKey === 'physics' || otherKey === key) return;

                const other = entities[otherKey];
                const dx = body.position.x - other.body.position.x;
                const dy = body.position.y - other.body.position.y;
                const distance = Math.hypot(dx, dy);
                const minDistance = 50 + 10; // NODE_SIZE + SPACING

                if (distance < minDistance && distance > 0) {
                    const angle = Math.atan2(dy, dx);
                    const force = 0.005;
                    const fx = Math.cos(angle) * force;
                    const fy = Math.sin(angle) * force;

                    Matter.Body.applyForce(body, body.position, { x: fx, y: fy });
                    Matter.Body.applyForce(other.body, other.body.position, { x: -fx, y: -fy });
                }
            });
        }
    });

    return entities;
};

export { engine, world, physics };
-e 

// ==== ./src/components/common/Icon.tsx ====

import { SvgProps } from 'react-native-svg';

import Plus from '../../assets/icons/lucide/plus.svg';
import ArrowLeft from '../../assets/icons/lucide/arrow-left.svg';
import Check from '../../assets/icons/lucide/check.svg';
import Lightbulb from '../../assets/icons/lucide/lightbulb.svg';
import Map from '../../assets/icons/lucide/map.svg';
import Settings from '../../assets/icons/lucide/settings.svg';

const iconMap = {
    plus: Plus,
    'arrow-left': ArrowLeft,
    check: Check,
    lightbulb: Lightbulb,
    map: Map,
    settings: Settings,
};

export type IconName = keyof typeof iconMap;

type Props = SvgProps & {
    name: IconName;
};

export function Icon({ name, ...props }: Props) {
    const Component = iconMap[name];
    return <Component {...props} />;
}
-e 

// ==== ./src/components/nodes/NodeCard.tsx ====

// src/components/nodes/NodeCard.tsx

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { PanGestureHandler } from 'react-native-gesture-handler';
import Animated, {
    useAnimatedGestureHandler,
    useSharedValue,
    useAnimatedStyle,
} from 'react-native-reanimated';
import Matter from 'matter-js';
import { NodeModel } from '../../types/NodeTypes';

type Props = {
    body: Matter.Body;
    node: NodeModel;
    size: [number, number];
    color: string;
};

const NodeCard: React.FC<Props> = ({ body, node, size, color }) => {
    const offsetX = useSharedValue(body.position.x - size[0] / 2);
    const offsetY = useSharedValue(body.position.y - size[1] / 2);

    const gestureHandler = useAnimatedGestureHandler({
        onStart: (_, ctx: any) => {
            ctx.startX = offsetX.value;
            ctx.startY = offsetY.value;
        },
        onActive: (event, ctx: any) => {
            offsetX.value = ctx.startX + event.translationX;
            offsetY.value = ctx.startY + event.translationY;
        },
        onEnd: () => {
            Matter.Body.setPosition(body, {
                x: offsetX.value + size[0] / 2,
                y: offsetY.value + size[1] / 2,
            });
        },
    });

    const animatedStyle = useAnimatedStyle(() => ({
        position: 'absolute',
        left: offsetX.value,
        top: offsetY.value,
        width: size[0],
        height: size[1],
        backgroundColor: color,
        borderRadius: 12,
        justifyContent: 'center',
        alignItems: 'center',
    }));

    return (
        <PanGestureHandler onGestureEvent={gestureHandler}>
            <Animated.View style={animatedStyle}>
                <Text style={styles.label}>{node.title}</Text>
            </Animated.View>
        </PanGestureHandler>
    );
};

const styles = StyleSheet.create({
    label: {
        color: '#1A1A1A',
        fontWeight: '500',
        textAlign: 'center',
    },
});

export default NodeCard;
-e 

// ==== ./src/navigation/AppNavigator.tsx ====

import React from 'react';
import BottomTabs from './BottomTabs';

export default function AppNavigator() {
    return <BottomTabs />;
}
-e 

// ==== ./src/navigation/BottomTabs.tsx ====

import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import CanvasScreen from '../screens/CanvasScreen';
import SettingsScreen from '../screens/SettingsScreen';
import { Icon } from '../components/common/Icon';
import { lightTheme } from '../theme/light';

const Tab = createBottomTabNavigator();

export default function BottomTabs() {
    return (
        <Tab.Navigator
            screenOptions={({ route }: { route: RouteProp<Record<string, object | undefined>, string> }) => {
                return {
                    headerStyle: { backgroundColor: lightTheme.background },
                    headerTitleStyle: { color: lightTheme.textPrimary },
                    tabBarStyle: { backgroundColor: lightTheme.background },
                    tabBarActiveTintColor: lightTheme.primary,
                    tabBarInactiveTintColor: lightTheme.textSecondary,
                    tabBarIcon: ({ color, size }: { color: string; size: number }) => {
                        const name = route.name === 'Canvas' ? 'map' : 'settings';
                        return <Icon name={name} width={size} height={size} stroke={color} />;
                    },
                } as BottomTabNavigationOptions;
            }}
        >
            <Tab.Screen name="Canvas" component={CanvasScreen} />
            <Tab.Screen name="Settings" component={SettingsScreen} />
        </Tab.Navigator>
    );
}
-e 

// ==== ./src/navigation/Routes.ts ====

export enum Routes {
    Canvas = 'Canvas',
    Map = 'Map',
    Settings = 'Settings',
}
-e 

// ==== ./src/screens/CanvasScreen.tsx ====

import React, { useEffect } from 'react';
import { View, StyleSheet, Pressable, Text } from 'react-native';
import Canvas from '../components/canvas/Canvas';
import { useMindMapStore } from '../state/useMindMapStore';

export default function CanvasScreen() {
    const loadNodes = useMindMapStore((s) => s.loadNodes);
    const clearNodes = useMindMapStore((s) => s.clearAllNodes);

    useEffect(() => {
        loadNodes();
    }, []);

    return (
        <View style={styles.container}>
            <Canvas />
            <Pressable style={styles.fab} onPress={clearNodes}>
                <Text style={styles.fabText}>ðŸ—‘</Text>
            </Pressable>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
    },
    fab: {
        position: 'absolute',
        right: 20,
        bottom: 20,
        backgroundColor: '#EB5757',
        width: 56,
        height: 56,
        borderRadius: 28,
        alignItems: 'center',
        justifyContent: 'center',
        elevation: 4,
    },
    fabText: {
        fontSize: 24,
        color: '#fff',
    },
});
-e 

// ==== ./src/screens/MapScreen.tsx ====

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { lightTheme } from '../theme/light';

export default function MapScreen() {
    return (
        <View style={styles.container}>
            <Text style={styles.text}>This is the Map screen</Text>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: lightTheme.background,
        alignItems: 'center',
        justifyContent: 'center',
    },
    text: {
        color: lightTheme.textPrimary,
        fontSize: 18,
    },
});
-e 

// ==== ./src/screens/SettingsScreen.tsx ====

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { lightTheme } from '../theme/light';

export default function SettingsScreen() {
    return (
        <View style={styles.container}>
            <Text style={styles.text}>This is the Settings screen</Text>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: lightTheme.background,
        alignItems: 'center',
        justifyContent: 'center',
    },
    text: {
        color: lightTheme.textPrimary,
        fontSize: 18,
    },
});
-e 

// ==== ./src/services/sqliteService.ts ====

import * as SQLite from 'expo-sqlite';
import { NodeModel } from '../types/NodeTypes';

let db: SQLite.SQLiteDatabase | null = null;

export async function initDatabase() {
  db = await SQLite.openDatabaseAsync('mindknot.db');

  await db.execAsync(`
    CREATE TABLE IF NOT EXISTS nodes (
      id TEXT PRIMARY KEY NOT NULL,
      title TEXT,
      body TEXT,
      icon TEXT,
      color TEXT,
      x REAL,
      y REAL,
      template TEXT,
      status TEXT,
      createdAt INTEGER,
      updatedAt INTEGER
    );
    
    CREATE TABLE IF NOT EXISTS links (
      id TEXT PRIMARY KEY NOT NULL,
      sourceId TEXT,
      targetId TEXT,
      type TEXT,
      createdAt INTEGER
    );
  `);
}

export async function getAllNodes(): Promise<NodeModel[]> {
  if (!db) return [];
  const result = await db.getAllAsync<NodeModel>('SELECT * FROM nodes;');
  return result;
}

export async function insertNode(node: NodeModel): Promise<void> {
  if (!db) return;
  await db.runAsync(
    `INSERT OR REPLACE INTO nodes 
      (id, title, body, icon, color, x, y, template, status, createdAt, updatedAt) 
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);`,
    [
      node.id,
      node.title,
      node.body || '',
      node.icon || '',
      node.color,
      node.x,
      node.y,
      node.template,
      node.status || '',
      node.createdAt,
      node.updatedAt,
    ]
  );
}

export async function updateNode(node: NodeModel): Promise<void> {
  if (!db) return;
  await db.runAsync(
    `UPDATE nodes SET x = ?, y = ?, updatedAt = ? WHERE id = ?;`,
    [node.x, node.y, node.updatedAt, node.id]
  );
}

export async function deleteAllNodes(): Promise<void> {
  if (!db) return;
  await db.runAsync('DELETE FROM nodes;');
}
-e 

// ==== ./src/state/useMindMapStore.ts ====

import { create } from 'zustand';
import { NodeModel } from '../types/NodeTypes';
import { getAllNodes, insertNode, updateNode, deleteAllNodes } from '../services/sqliteService';
import { nanoid } from 'nanoid/non-secure';

type MindMapState = {
    nodes: NodeModel[];
    loadNodes: () => Promise<void>;
    addNode: (partial: Partial<NodeModel>) => Promise<void>;
    updateNodePosition: (id: string, x: number, y: number) => Promise<void>;
    clearAllNodes: () => Promise<void>;
};

export const useMindMapStore = create<MindMapState>((set, get) => ({
    nodes: [],

    loadNodes: async () => {
        const loaded: NodeModel[] = await getAllNodes();
        set({ nodes: loaded });
    },

    addNode: async (partial) => {
        const now = Date.now();
        const node: NodeModel = {
            id: nanoid(),
            title: partial.title || 'Untitled',
            body: partial.body || '',
            icon: partial.icon || '',
            color: partial.color || '#2D9CDB',
            x: partial.x ?? 0,
            y: partial.y ?? 0,
            template: partial.template || 'quicknote',
            status: partial.status || '',
            createdAt: now,
            updatedAt: now,
        };
        await insertNode(node);
        set((state) => ({ nodes: [...state.nodes, node] }));
    },

    updateNodePosition: async (id, x, y) => {
        const now = Date.now();
        set((state) => {
            const updatedNodes = state.nodes.map((node) =>
                node.id === id ? { ...node, x, y, updatedAt: now } : node
            );
            return { nodes: updatedNodes };
        });

        const updatedNode = get().nodes.find((node) => node.id === id);
        if (updatedNode) {
            await updateNode({ ...updatedNode, x, y, updatedAt: now });
        }
    },

    clearAllNodes: async () => {
        await deleteAllNodes();
        set({ nodes: [] });
    },
}));
-e 

// ==== ./src/styles/colors.ts ====

export const baseColors = {
    white: '#ffffff',
    black: '#000000',
    nodeBlue: '#2D9CDB',
    urgentRed: '#EB5757',
    textSecondary: '#666666',
};

export const lightColors = {
    background: '#ffffff',
    textPrimary: '#1A1A1A',
    surface: '#F2F2F2',
    border: '#E0E0E0',
};

export const darkColors = {
    background: '#121212',
    textPrimary: '#ffffff',
    surface: '#1E1E1E',
    border: '#333333',
};
-e 

// ==== ./src/styles/index.ts ====

export * from './colors';
export * from './spacing';
export * from './typography';
-e 

// ==== ./src/styles/spacing.ts ====

export const spacing = {
    xs: 4,
    s: 8,
    m: 16,
    l: 24,
    xl: 32,
};
-e 

// ==== ./src/styles/typography.ts ====

export const typography = {
    fontSize: {
      xs: 10,
      s: 12,
      m: 14,
      l: 18,
      xl: 24,
      xxl: 32,
    },
    fontWeight: {
      regular: '400',
      medium: '500',
      bold: '700',
    },
    lineHeight: {
      tight: 16,
      normal: 20,
      relaxed: 28,
    },
  };
  -e 

// ==== ./src/theme/dark.ts ====

import { baseColors, darkColors } from '../styles/colors';

export const darkTheme = {
    ...darkColors,
    ...baseColors,
    primary: baseColors.nodeBlue,
};
-e 

// ==== ./src/theme/light.ts ====

import { baseColors, lightColors } from '../styles/colors';

export const lightTheme = {
    ...lightColors,
    ...baseColors,
    primary: baseColors.nodeBlue,
};
-e 

// ==== ./src/types/NodeTypes.ts ====

export type NodeTemplate = 'quicknote' | 'checklist' | 'bullet' | 'decision';

export interface NodeModel {
    id: string;
    title: string;
    body?: string;
    icon?: string;
    color: string;
    x: number;
    y: number;
    template: NodeTemplate;
    status?: string;
    createdAt: number;
    updatedAt: number;
}

export interface LinkModel {
    id: string;
    sourceId: string;
    targetId: string;
    type: 'default' | 'cause' | 'reference' | 'related';
    createdAt: number;
}
-e 

// ==== ./src/types/svg.d.ts ====

declare module '*.svg' {
    import * as React from 'react';
    import { SvgProps } from 'react-native-svg';
    const content: React.FC<SvgProps>;
    export default content;
}
